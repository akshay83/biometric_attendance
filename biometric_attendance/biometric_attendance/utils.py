import frappe
import time
import json
from .zk import ZK
from .zk.finger import Finger

@frappe.whitelist()
def get_biometric_user_name(user):
	return frappe.db.get_value("Biometric Users", { "name": user }, "user_name")

@frappe.whitelist()
def get_biometric_user_from_user_id(user_id):
	return "BU"+("{:0>6}".format(int(user_id)))

@frappe.whitelist()
def check_connection(machine_name=None):
	if not machine_name:
		return
	machine_doc = frappe.get_doc("Biometric Machine", machine_name)
	conn = None
	success = False
	try:
		zk = ZK(machine_doc.ip_domain_address, machine_doc.port)
		conn = zk.connect()
		if conn:
			success = True
	except Exception as e:
		frappe.throw(e)
	finally:
		if conn:
			conn.disconnect()
	return success

@frappe.whitelist()
def import_attendance(machine_name=None):
	if not machine_name:
		return
	machine_doc = frappe.get_doc("Biometric Machine", machine_name)
	conn = None
	success = False

	try:
		zk = ZK(machine_doc.ip_domain_address, machine_doc.port)
		conn = zk.connect()

		conn.read_sizes()
		i = 0

		attendance = conn.get_attendance()
		for a in attendance:
			attendance_doc = frappe.new_doc("Biometric Attendance")
			attendance_doc.uid = a.uid
			attendance_doc.user_id = a.user_id
			attendance_doc.timestamp = a.timestamp
			attendance_doc.punch = a.punch
			attendance_doc.status = a.status
			i = i + 1
			frappe.publish_realtime('import_biometric_attendance', dict(
						progress=i,
						total=conn.records
					), user=frappe.session.user)
			attendance_doc.save()

		success = True

	except Exception as e:
		frappe.throw(e)
	finally:
		if conn:
			conn.disconnect()

	return success

@frappe.whitelist()
def clear_machine_attendance(machine_name=None):
	if not machine_name:
		return
	conn = None
	machine_doc = frappe.get_doc("Biometric Machine", machine_name)
	success = False
	try:
		zk = ZK(machine_doc.ip_domain_address, machine_doc.port)
		conn = zk.connect()
		conn.clear_attendance()
		success = True
	except Exception as e:
		frappe.throw(e)
	finally:
		if conn:
			conn.disconnect()

	return success

@frappe.whitelist()
def sync_users(machine_name=None):
	"""
	Points:
		1. user_id -> Custom User ID Set by US (System)
		2. uid -> User ID Generated by Machine
		As per understanding, 'user_id' is unique. So What we have done is to trim and use `Biometric User` Name to set as 'user_id',
		and let the machine manage 'uid'. So while adding user to a machine, add using trimmed 'user_id'. And Whenever we need to 
		access machine using 'uid', match 'user_id' and get 'uid' first from the machine. 
	"""
	if not machine_name:
		return
	conn = None
	machine_doc = frappe.get_doc("Biometric Machine", machine_name)
	success = False
	try:
		zk = ZK(machine_doc.ip_domain_address, machine_doc.port)
		conn = zk.connect()
		conn.read_sizes()
		if conn.records == 0:
			machine_users = conn.get_users()
			machine_user_ids = []
			system_user_ids = []
			#Build List of Current Machine User IDs
			for m in machine_users:
				machine_user_ids.append(m.user_id)
			#Build List of Current Users in the Machine Document -> System
			for u in machine_doc.users:
				user_id = str(int(u.user[2:]))
				system_user_ids.append(user_id)
			#If User ID not in Machine But present in Document (System) -> Then Add
			for u in machine_doc.users:
				user_id = str(int(u.user[2:]))
				if user_id not in machine_user_ids:
					conn.set_user(user_id=user_id, name=u.user_name)
			#If User ID not in Document (System) But Present in Machine -> Then Delete
			for m in machine_users:
				if m.user_id not in system_user_ids:
					conn.delete_user(user_id=m.user_id)
			success = True
	except Exception as e:
		frappe.throw(e)
	finally:
		if conn:
			if conn.records > 0:
				frappe.msgprint("Attendance Records Exists")
			conn.disconnect()

	return success

@frappe.whitelist()
def delete_duplicate_rows_from_attendance():
	query = """
			delete t1 
			from 	`tabBiometric Attendance` t1 
				inner join 
				`tabBiometric Attendance` t2 
			where 
				t1.name < t2.name 
				and (t1.user_id = t2.user_id and t1.timestamp = t2.timestamp)
		"""
	frappe.db.sql(query)
	return True

@frappe.whitelist()
def sync_fingerprints(machine_name):
	machine_doc = frappe.get_doc("Biometric Machine", machine_name)
	conn = None
	success = False
	all_fingers = []
	try:
		zk = ZK(machine_doc.ip_domain_address, machine_doc.port)
		conn = zk.connect()
		#Get All Machine Available Fingerprints, Using `Build Userwise Method` as this will call get_templates() on once
		all_fingers = build_userwise_fingerprint_dict(conn.get_templates())
		for k,v in all_fingers.items():
			user_id = get_user_id_from_machine_uid(conn, k)
			biometric_user = get_biometric_user_from_user_id(user_id)
			frappe.db.set_value("Biometric Users", biometric_user, "fingerprint_data", get_json_string_of_fingers(v))
		success = True
	except Exception as e:
		frappe.throw(e)
	finally:
		if conn:
			conn.disconnect()
	return success

def get_machine_uid_from_user_id(conn, user_id):
	users = conn.get_users()
	for u in users:
		#--DEBUG--print (u.user_id, user_id)
		if int(u.user_id) == int(user_id):
			return u.uid
	return None

def get_user_id_from_machine_uid(conn, uid):
	users = conn.get_users()
	for u in users:
		#--DEBUG--print (u.uid, uid)
		if int(u.uid) == int(uid):
			return u.user_id
	return None

#Return "Finger" List of fingers from a Connection to a Machine for an User
def get_user_fingers(connection, user_id=None, biometric_user=None):
	if not connection:
		return None
	if not user_id and not biometric_user:
		return None
	if biometric_user and not user_id:
		user_id = str(int(biometric_user[2:]))
	try:
		uid = get_machine_uid_from_user_id(connection, user_id)
		if uid:
			#Get All Fingers in Machine, Not recomended Method to get finger prints for all users
			fingers = connection.get_templates()
			result_fingers = []
			#Match Userid with Finger UID
			for f in fingers:
				if f.uid == uid:
					result_fingers.append(f)
			return result_fingers
	except Exception as e:
		frappe.throw(e)	

def get_user_fingers_from_machine(machine_name,user_id=None,biometric_user=None):
	machine_doc = frappe.get_doc("Biometric Machine", machine_name)
	conn = None
	fingers = None
	try:
		zk = ZK(machine_doc.ip_domain_address, machine_doc.port)
		conn = zk.connect()
		fingers = get_user_fingers(conn, user_id, biometric_user)
	except Exception as e:
		frappe.throw(e)
	finally:
		if conn:
			conn.disconnect()
	return fingers		

#Get Json String representation of a List of Fingers (Using Finger Class)
def get_json_string_of_fingers(fingers):
	if not fingers:
		return None
	if isinstance(fingers, Finger):
		fingers = [fingers]
	json_representation = []
	for f in fingers:
		json_representation.append(f.json_pack())	
	return json.dumps(json_representation)

#Builds List of Fingers (Finger Class), from a Json Dump
def build_fingers_from_json(json_fingers):
	if not json_fingers:
		return None
	if isinstance(json_fingers, str):
		json_fingers = json.loads(json_fingers)
	if not isinstance(json_fingers, list):
		json_fingers = [json_fingers]
	fingers = []
	for f in json_fingers:
		fingers.append(Finger.json_unpack(f))
	return fingers

def build_userwise_fingerprint_dict(fingers):
	if not fingers:
		return None
	finger_dict = {}
	for f in fingers:
		if f.uid in finger_dict:
			finger_dict[f.uid].append(f)
		else:
			finger_dict.update({
				f.uid:[f]
			})
	return finger_dict